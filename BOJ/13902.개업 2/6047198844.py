# 문제
# 해빈이는 양손잡이여서 동시에 두 개의 웍(중국 냄비)을 사용하여 요리할 수 있다. 필요 이상 크기의 웍을 사용하지 않으며, 주문 받은 짜장면의 그릇 수에 딱 맞게 요리한다.
# 예를 들어 짜장면 4그릇을 주문 받았는데 5그릇 이상을 요리하지 않으며, 4그릇을 요리할 수 있는 웍에 3그릇 이하의 요리를 하지 않는다.
#
# 해빈이가 5그릇을 주문 받았고, 해빈이가 가지고 있는 웍의 종류가 1, 3그릇 용이라면 처음에 1,3그릇용 웍을 동시에 이용하여 4그릇을 만들고 다음 1그릇용 웍을 이용하여 1그릇을 만들어 총 5그릇을 두 번의 요리로 만들 수 있다.
#
# 해빈이가 주문 받은 짜장면의 수와 가지고 있는 웍의 크기가 주어질 때, 최소 몇 번의 요리로 모든 주문을 처리할 수 있는지 출력하는 프로그램을 작성하시오.
#
# 입력
# 첫 번째 줄에는 해빈이가 주문 받은 짜장면의 수N(1≤N≤10,000)과 가지고 있는 웍의 개수 M(1≤M≤1,000)이 주어진다. 두 번째 줄에는 웍의 크기 Si(1≤Si≤N)이 M개가 주어지며 같은 크기의 웍을 여러 개 가지고 있을 수 있다.
#
# 출력
# 해빈이가 모든 주문을 처리하기 위해 해야 하는 최소 요리 횟수를 출력한다. 만약 모든 주문을 처리 할 수 없는 경우 -1을 출력한다.
from itertools import combinations

N, M = map(int, input().split())
wack = list(map(int, input().split()))

for i, j in combinations(wack, 2):
    if i + j <= N:
        wack.append(i + j)
# 중복제거, 한 요리수로 만들수있는 모든 그릇수
wack = list(set(wack))

# dishes[N] = N 그릇을 만드는데 필요한 최소 요리수.
dishes = [0 for _ in range(N+1)]

for i in wack:
    # i 는 한번 요리로 만들수있는 그릇수. -> 무조건 최소 비용 1이다.
    dishes[i] = 1
    for j in range(i+1, N+1):
        # j - i : X번 요리로 만든 그릇수. 이떄 X는 최소임이 보장된다.
        # dishes[j - i] : X번. 만약에 0이라면 만들 수 없는것.
        if dishes[j - i] != 0 and (dishes[j] == 0 or dishes[j] > dishes[j - i] + 1):
            dishes[j] = dishes[j - i] + 1

print(dishes[N]) if dishes[N] != 0 else print(-1)